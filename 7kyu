// Example_1 //
// Is this a triangle? //
// firstSolution //

function isTriangle(a,b,c) {
    if ((a + b > c) && (a + c > b) && (b + c > a)) {
      return true;
    } else {
     return false;
  }
}

// secondSolution //

function isTriangle(a,b,c) {
   return a + b > c && a + c > b && b + c > a;
}

 // Sample test

Test.describe("PublicTest", function() {
    Test.assertEquals(isTriangle(1,2,2), true);
    Test.assertEquals(isTriangle(7,2,2), false);
});


// Example_2 //
// Friend or Foe?
// Make a program that filters a list of strings and returns a list with only your friends name in it. //
// If a name has exactly 4 letters in it, you can be sure that it has to be a friend of yours! //

// firstSolution //

function friend(friends){
  var realFriends = [];
  for (var i = 0; i < friends.length; i++ ) {
    if (friends[i].length == 4) {
      realFriends.push(friends[i]);
    } 
  }
  return realFriends;
}

// secondSolution //

function friend(friends){
  return friends.filter(n => n.length === 4);
}


    // Sample tests

    Test.assertSimilar(friend(["Ryan", "Kieran", "Mark"]), ["Ryan", "Mark"]);
    Test.assertSimilar(friend(["Ryan", "Jimmy", "123", "4", "Cool Man"]), ["Ryan"]);
    Test.assertSimilar(friend(["Jimm", "Cari", "aret", "truehdnviegkwgvke", "sixtyiscooooool"]), ["Jimm", "Cari", "aret"]);
    Test.assertSimilar(friend(["Love", "Your", "Face", "1"]), ["Love", "Your", "Face"]);


// Example_3 //
// Reverse words //
// firstSolution // 

function reverseWords(str) {
 return str.split("").reverse().join("").split(/\s/g).reverse().join(" ");
}

// secondSolution //

function reverseWords(str) {
  return str.split(" ").map(str => str.split("").reverse().join("")).join(" ");
}

    // Sample tests //

    Test.describe('Sample Tests', _ => {
      Test.it('Should pass Sample tests', _ => {
        Test.assertEquals(reverseWords('The quick brown fox jumps over the lazy dog.'), 'ehT kciuq nworb xof spmuj revo eht yzal .god');
        Test.assertEquals(reverseWords('apple'), 'elppa');
        Test.assertEquals(reverseWords('a b c d'), 'a b c d');
        Test.assertEquals(reverseWords('double  spaced  words'), 'elbuod  decaps  sdrow');
      });
    });


// Example_4 //
// Descending order //

function descendingOrder(n){
  return parseInt(Array.from(String(n), Number).sort((a,b) => b - a).join(""));
}

    // Sample tests //

    Test.assertEquals(descendingOrder(0), 0)
    Test.assertEquals(descendingOrder(1), 1)
    Test.assertEquals(descendingOrder(123456789), 987654321)
    
// Example_5 //
// The Club Doorman will give you a word. 
// To enter the Club you need to provide the right number according to provided the word.
// Every given word has a doubled letter, like 'tt' in lettuce.
// You need to find the doubled letter's position of the given word in the alphabet and multiply this number per 3.

// firstSolution
 
 function passTheDoorMan (word){
  var doubleLetter;
  for (var i = 0; i < word.length-1; i++) 
    if (word[i] == word[i+1]) {
      doubleLetter = word[i];
      break;
    }
  return (doubleLetter.charCodeAt()-96)*3;
}

// secondSolution //

const passTheDoorMan = word => ((word.match(/(.)\1/)[1]).charCodeAt(0) - 96) * 3;

    // Sample tests //

     describe("Club Doorman", function(){
       it("Basic Tests", function(){
        Test.assertSimilar( passTheDoorMan("lettuce") , 60);
        Test.assertSimilar( passTheDoorMan("hill"), 36);
        Test.assertSimilar( passTheDoorMan("apple"), 48);
      });
     });  

// Example_6 //
// Simple Fun #152: Invite More Women? //
// firstSolution //

function inviteMoreWomen(L) {
  var men = 0;
  var women = 0;
  for (var i = 0; i < L.length; i++) {
    if ( L[i] > 0 ) {
      men += 1;
    } else {
      women += 1;
    }
  }
  
  if (men > women) {
    return true;
  } else {
    return false;
  }
}

// secondSolution

const inviteMoreWomen = L => L.reduce((a,b) => a+b) > 0;


    // Sample tests //

    describe("Basic Tests", function(){
    it("It should works for basic tests.", function(){

    Test.assertEquals(inviteMoreWomen([1, -1, 1]),true)

    Test.assertEquals(inviteMoreWomen([1, 1, 1]),true)

    Test.assertEquals(inviteMoreWomen([-1, -1, -1]),false)

    Test.assertEquals(inviteMoreWomen([1, -1]),false)

    })})

// Example_7 //
// Your task is to write a function that takes a string and return a new string with all vowels removed //

const disemvowel = str => str.replace(/[aeiou]/gi, '');

    // Sample tests //

    Test.assertEquals(disemvowel("This website is for losers LOL!"),
      "Ths wbst s fr lsrs LL!")
  
  // Example_8 //
  // return the first m multiples of n //
  // firstSolution //
  
 function multiples(m, n){
    let result = [];
    for (let i = 1; i <= m; i++) {
        result.push(i*n);
 }
    return result;
}

// secondSolution

const multiples = (m, n) => Array.from(Array(m), (_, i) => n* i + n);



    // Sample tests //

    Test.assertDeepEquals(multiples(3, 5), [5, 10, 15])

// Example_8 
// Complementary DNA

// firstSolution

function DNAStrand(dna){
  let complementDNA = '';
  for(let i = 0; i < dna.length; i++){
    if(dna[i] === 'T'){
      complementDNA += 'A';
    }
    if(dna[i] === 'A'){
      complementDNA += 'T';
    }
    if(dna[i] === 'C'){
      complementDNA += 'G';
    }
    if(dna[i] === 'G'){
      complementDNA += 'C';
    }
  }
  return complementDNA;
}


// secondSolution

const DNAStrand = dna => dna.replace(/./g, x => "ATCG"["TAGC".indexOf(x)]);

    // Sample tests

    Test.assertEquals(DNAStrand("AAAA"),"TTTT","String AAAA is");
    Test.assertEquals(DNAStrand("ATTGC"),"TAACG","String ATTGC is");
    Test.assertEquals(DNAStrand("GTAT"),"CATA","String GTAT is");
    
    
// Example_9
// Given the triangle of consecutive odd numbers:

             1
          3     5
       7     9    11
   13    15    17    19
21    23    25    27    29
...


const rowSumOddNumbers = n => Math.pow(n, 3);

    // Sample tests

    Test.assertEquals(rowSumOddNumbers(1), 1);
    Test.assertEquals(rowSumOddNumbers(42), 74088);


// Example_10
// Your task is to add up letters to one letter.
// The function will be given a variable amount of arguments, each one being a letter to add.
// Notes:
// Letters will always be lowercase.
// Letters can overflow (see second to last example of the description)
// If no letters are given, the function should return 'z'

const addLetters = (...letters) => String.fromCharCode((letters.reduce((sum, x) => sum + x.charCodeAt() - 96, 0) % 26 || 26) + 96);


    // Sample tests

    addLetters('a', 'b', 'c') = 'f'
    addLetters('a', 'b') = 'c'
    addLetters('z') = 'z'
    addLetters('z', 'a') = 'a'
    addLetters('y', 'c', 'b') = 'd' // notice the letters overflowing
    addLetters() = 'z'
    
    
// Example_11
// Potato Paradox
// All we eat is water and dry matter.
// John bought potatoes: their weight is 100 kilograms. Potatoes contain water and dry matter.
// The water content is 99 percent of the total weight. He thinks they are too wet and puts them in an oven - at low temperature - for them to lose some water.
// At the output the water content is only 98%.
// What is the total weight in kilograms (water content plus dry matter) coming out of the oven?
// He finds 50 kilograms and he thinks he made a mistake: "So much weight lost for such a small change in water content!"
// Can you help him?
// Write function potatoes with
// int parameter p0 - initial percent of water-
// int parameter w0 - initial weight -
// int parameter p1 - final percent of water -
// potatoesshould return the final weight coming out of the oven w1 truncated as an int.
// Example:
// potatoes(99, 100, 98) --> 50


const potatoes = (p0, w0, p1) => Math.floor(w0 * (100 - p0) / (100 - p1));


    // Sample tests

    Test.describe("Basic tests",function() {
        Test.it("potatoes",function() {
            Test.assertEquals(potatoes(82, 127, 80), 114);
            Test.assertEquals(potatoes(93, 129, 91), 100);

    })})
    
// Example_12
// Population Growth
// In a small town the population is p0 = 1000 at the beginning of a year. The population regularly increases by 2 percent per year and moreover 50 new inhabitants per year come to live in the town. How many years does the town need to see its population greater or equal to p = 1200 inhabitants?
// At the end of the first year there will be: 
// 1000 + 1000 * 0.02 + 50 => 1070 inhabitants
// At the end of the 2nd year there will be: 
// 1070 + 1070 * 0.02 + 50 => 1141 inhabitants (number of inhabitants is an integer)
// At the end of the 3rd year there will be:
// 1141 + 1141 * 0.02 + 50 => 1213
// It will need 3 entire years.
// More generally given parameters:
// p0, percent, aug (inhabitants coming or leaving each year), p (population to surpass)
// the function nb_year should return n number of entire years needed to get a population greater or equal to p.
// aug is an integer, percent a positive or null number, p0 and p are positive integers (> 0)

// Examples:
// nb_year(1500, 5, 100, 5000) -> 15
// nb_year(1500000, 2.5, 10000, 2000000) -> 10
//Note: Don't forget to convert the percent parameter as a percentage in the body of your function: if the parameter percent is 2 you have to convert it to 0.02.

function nbYear(p0, percent, aug, p) {
    let count = 0;
    while ( p0 < p ) {
      p0 = p0 + ((p0 * percent) / 100) + aug;
      count++;
    }
  return count;
}

    // Sample tests

    Test.describe("nbYear",function() {
    Test.it("Basic tests",function() {    
        Test.assertEquals(nbYear(1500, 5, 100, 5000), 15);
        Test.assertEquals(nbYear(1500000, 2.5, 10000, 2000000), 10);
        Test.assertEquals(nbYear(1500000, 0.25, 1000, 2000000), 94);
    })})

// Example_13
// Binary Addition
// Implement a function that adds two numbers together and returns their sum in binary. 
// The conversion can be done before, or after the addition.
// The binary number returned should be a string.


const addBinary= (a,b) => (a + b).toString(2);


    // Sample tests

    Test.describe("addBinary(1,2)", function() {
      var results1 = addBinary(1,2);
      Test.it("Should return something that isn't falsy", function() {
        Test.expect(results1, "Something is wrong, no results!");
      });
      Test.it("Should return \"11\"", function() {
        Test.assertEquals(results1, "11");
      });
    });

// Example_14
// Spacify
// Modify the spacify function so that it returns the given string with spaces insertedbetween each character.
// spacify("hello world") // returns "h e l l o   w o r l d"

const spacify = str => str.split("").join(" ");

    // Sample tests

    const {assert} = require("chai");

    describe("spacify", function() {
      it("basic tests", function() {
        assert.equal(spacify('hello world'),'h e l l o   w o r l d');
        assert.equal(spacify('12345'),'1 2 3 4 5');
      });
    });


// Example_15
// Scenario
// the rhythm of beautiful musical notes is drawing a Pendulum
// Beautiful musical notes are the Numbers !alt !alt
// Task
// Given an array/list [] of n integers , Arrange them in a way similar to the to-and-fro movement of a Pendulum
// The Smallest element of the list of integers , must come in center position of array/list.
// The Higher than smallest , goes to the right .
// The Next higher number goes to the left of minimum number and So on , in a to-and-fro manner similar to that of a Pendulum.
// !alt
// Notes
// Array/list size is at least *3*** .
// In Even array size , The minimum element should be moved to (n-1)/2 index (considering that indexes start from 0)
// Repetition of numbers in the array/list could occur , So (duplications are included when Arranging).
// Input >> Output Examples:
// pendulum ([6, 6, 8 ,5 ,10]) ==> [10, 6, 5, 6, 8]
// Explanation:
// Since , 5 is the The Smallest element of the list of integers , came in The center position of array/list
// The Higher than smallest is 6 goes to the right of 5 .
// The Next higher number goes to the left of minimum number and So on .
// Remeber , Duplications are included when Arranging , Don't Delete Them .
// pendulum ([-9, -2, -10, -6]) ==> [-6, -10, -9, -2]
// Explanation:
// Since , -10 is the The Smallest element of the list of integers , came in The center position of array/list
// The Higher than smallest is -9 goes to the right of it .
// The Next higher number goes to the left of -10 , and So on .
// Remeber , In Even array size , The minimum element moved to (n-1)/2 index (considering that indexes start from 0) .
// pendulum ([11, -16, -18, 13, -11, -12, 3, 18 ]) ==> [13, 3, -12, -18, -16, -11, 11, 18]
// Explanation:
// Since , -18 is the The Smallest element of the list of integers , came in The center position of array/list
// The Higher than smallest is -16 goes to the right of it .
// The Next higher number goes to the left of -18 , and So on .
// Remember , In Even array size , The minimum element moved to (n-1)/2 index (considering that indexes start from 0) .

function pendulum(values) {
  let arr = [];
  let result = [];
  values.sort((x, y) => x - y).forEach((y, x) => (x % 2 ? arr : result).push(y));
  return result.reverse().concat(arr)
}

    // Sample tests 

    const { assert } = require("chai");

    describe("The Poet And The Pendulum", function(){
        function doTest(values, expected) {
            assert.deepEqual(pendulum(values), expected);
        }
        it("Check Short length Positives", function(){
            doTest([4,10,9], [10,4,9])
            doTest([8,7,10,3], [8,3,7,10])
            doTest([6,6,8,5,10], [10,6,5,6,8])
            doTest([9,4,6,4,10,5], [9,5,4,4,6,10])
            doTest([4,6,8,7,5], [8,6,4,5,7])
            doTest([10,5,6,10], [10,5,6,10])
            doTest([11,12,12], [12,11,12])
        })
        it("Check Medium length Positives", function(){
            doTest([27,27,19,21,22,28,24], [28,27,22,19,21,24,27])
            doTest([20,19,25,16,19,30,18,24], [25,20,19,16,18,19,24,30])
            doTest([22,26,21,27,24,21,15,26,25], [27,26,24,21,15,21,22,25,26])
            doTest([19,30,16,19,28,26,28,17,21,17], [28,26,19,17,16,17,19,21,28,30])
            doTest([27,28,26,28,24,22,18,16,15,24], [28,26,24,18,15,16,22,24,27,28])
            doTest([17,26,15,26,26,20,16,18,15], [26,26,18,16,15,15,17,20,26])
            doTest([22,21,19,27,18,15,24,24], [24,22,19,15,18,21,24,27])
        })
        it("Check lengthy Positives", function(){
            doTest([33,38,38,36,43,48,32,40,47,50,33], [50,47,40,38,33,32,33,36,38,43,48])
            doTest([49,40,41,41,39,43,40,46,30,47,46,40], [47,46,41,40,40,30,39,40,41,43,46,49])
            doTest([48,41,38,35,50,46,38,42,37,49,44,32,37], [50,48,44,41,38,37,32,35,37,38,42,46,49])
            doTest([49,30,39,30,40,44,43,48,47,50,42,48,33], [50,48,47,43,40,33,30,30,39,42,44,48,49])
            doTest([48,43,35,47,39,38,38,46,49,32,42], [49,47,43,39,38,32,35,38,42,46,48])
        })
        it("Check Short length Negatives", function(){
            doTest([-9,-2,-10,-6], [-6,-10,-9,-2])
            doTest([-3,-6,-7], [-3,-7,-6])
            doTest([-7,-8,-2,-3,-4], [-2,-4,-8,-7,-3])
            doTest([-8,-8,-9,-10,-10,-3], [-8,-9,-10,-10,-8,-3])
            doTest([-7,-10,-1,-10,-8], [-1,-8,-10,-10,-7])
            doTest([-6,-2,-5], [-2,-6,-5])
        })
        it("Check Medium length Negatives", function(){
            doTest([-2,-11,-6,-11,-4,-3,-5], [-2,-4,-6,-11,-11,-5,-3])
            doTest([-19,-9,-5,-6,-15,-16,-5,-12], [-5,-9,-15,-19,-16,-12,-6,-5])
            doTest([-18,-2,-11,-10,-6,-7,-7,-12,-16], [-2,-7,-10,-12,-18,-16,-11,-7,-6])
            doTest([-10,-10,-12,-13,-5,-10,-4,-17,-5,-12], [-5,-10,-10,-12,-17,-13,-12,-10,-5,-4])
        })
        it("Check lengthy Negatives", function(){
            doTest([-33,-21,-6,-29,-24,-5,-50,-42,-43,-17,-17], [-5,-17,-21,-29,-42,-50,-43,-33,-24,-17,-6])
            doTest([-4,-50,-32,-23,-47,-44,-43,-24,-29,-44,-20,-35], [-20,-24,-32,-43,-44,-50,-47,-44,-35,-29,-23,-4])
            doTest([-36,-38,-44,-47,-41,-27,-10,-30,-22,-11,-23,-50,-23], [-10,-22,-23,-30,-38,-44,-50,-47,-41,-36,-27,-23,-11])
        })
        it("Check Mixture Of Positives And Negatives", function(){
            doTest([-15,8,11], [11,-15,8])
            doTest([8,-1,-1,-10], [-1,-10,-1,8])
            doTest([-8,15,8,-3,-11], [15,-3,-11,-8,8])
            doTest([15,17,3,-20,-1,3], [15,3,-20,-1,3,17])
            doTest([-8,-13,-19,-8,7,15,-10], [15,-8,-10,-19,-13,-8,7])
            doTest([11,-16,-18,13,-11,-12,3,18], [13,3,-12,-18,-16,-11,11,18])
            doTest([7,-5,-20,15,2,10,18,4,-10], [18,10,4,-5,-20,-10,2,7,15])
            doTest([-6,1,2,12,19,12,19,-10,13,1], [19,12,2,1,-10,-6,1,12,13,19])
        })
    })

// Example_16 
// No Story
// No Description
// Only by Thinking and Testing
// Look at the results of the testcases, and guess the code!

// firstSolution

function testit(arr){
  let a = arr[0] * arr[3];
  let b = arr[1] * arr[2];
  return a + b;
}

// secondSolution

const  testit = ([a, b, c, d]) => b * c + a * d;

    // Sample tests

    //Add? subtract? multiply? divide? Who and who?
    Test.assertSimilar(testit([0,0,0,0]), 0, "")
    Test.assertSimilar(testit([0,0,0,1]), 0, "")
    Test.assertSimilar(testit([0,0,1,1]), 0, "")
    Test.assertSimilar(testit([0,1,0,1]), 0, "")
    Test.assertSimilar(testit([0,1,1,0]), 1, "")
    Test.assertSimilar(testit([1,0,0,1]), 1, "")
    Test.assertSimilar(testit([9,2,7,0]), 14, "")
    Test.assertSimilar(testit([8,2,6,4)), 44, "")
    Test.assertSimilar(testit([9,5,9,5]), 90, "")
    Test.assertSimilar(testit([4,4,1,9]), 40, "")


// Example_17
// String ends with?
// Complete the solution so that it returns true if the first argument(string) passed in ends with the 2nd argument (also a string).

// firstSolution

const solution = (str, ending) => str.includes(ending, [str.length - ending.length]);

// secondSolution

const solution = (str, ending) => str.endsWith(ending);

    // Sample tests

    Test.assertEquals(solution('abcde', 'cde'), true)
    Test.assertEquals(solution('abcde', 'abc'), false)

// Example_18
// Password Hashes
// When you sign up for an account somewhere, some websites do not actually store your password in their databases. Instead, they will transform your password into something else using a cryptographic hashing algorithm.
// After the password is transformed, it is then called a password hash. Whenever you try to login, the website will transform the password you tried using the same hashing algorithm and simply see if the password hashes are the same.
// Create the function that converts a given string into an md5 hash. The return value should be encoded in hexadecimal.

const passHash = str => require('crypto').createHash('md5').update(str).digest('hex');

    // Sample tests

    var tests = [
      ['password', '5f4dcc3b5aa765d61d8327deb882cf99'],
      ['abc123', 'e99a18c428cb38d5f260853678922e03']
    ]

    for (var i = 0; i < tests.length; i++) {
      Test.assertEquals(passHash(tests[i][0]), tests[i][1])
    }

